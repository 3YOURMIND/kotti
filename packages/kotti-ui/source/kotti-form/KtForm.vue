<template>
	<form @submit.prevent="onSubmit">
		<slot name="default" />
		<!-- onSubmit only triggers if there is a submit button in the form -->
		<input v-show="false" type="submit" />
	</form>
</template>

<script lang="ts">
import {
	computed,
	defineComponent,
	provide,
	reactive,
} from '@vue/composition-api'
import cloneDeep from 'lodash/cloneDeep'

import { KOTTI_FIELD_INHERITABLE_PROPS } from '../kotti-field/constants'
import { KottiField } from '../kotti-field/types'

import { KT_FORM_CONTEXT, KT_FORM_SUBMIT_CONTEXT } from './constants'
import { KtFormErrors } from './errors'
import { KottiForm } from './types'
import { getValidationSummary } from './utilities'

let id = 0

export default defineComponent({
	name: 'KtForm',
	props: {
		...KOTTI_FIELD_INHERITABLE_PROPS,
		formId: { default: () => `autoGeneratedFormId${++id}`, type: String },
		preventSubmissionOn: {
			default: 'error',
			type: String,
			validator: (
				value: string,
			): value is KottiForm.Props['preventSubmissionOn'] =>
				['error', 'warning', 'NEVER'].includes(value),
		},
		validators: { default: () => ({}), type: Object },
		value: { required: true, type: Object },
	},
	setup(props: KottiForm.Props, { emit }) {
		const currentFieldsWrapper = reactive<{
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			currentFields: KottiField.Hook.Returns<any>[]
		}>({ currentFields: [] })

		const values = computed(() => cloneDeep(props.value))
		const isLoading = computed(() => props.isLoading)

		provide<KottiForm.Context>(KT_FORM_CONTEXT, {
			fieldInheritableProps: computed(() => ({
				hideClear: props.hideClear,
				hideValidation: props.hideValidation,
				isDisabled: props.isDisabled,
				isLoading: props.isLoading,
				size: props.size,
			})),
			formPath: computed(() => [props.formId]),
			onAddField(toAdd) {
				currentFieldsWrapper.currentFields = [
					...currentFieldsWrapper.currentFields,
					toAdd,
				]
			},
			onRemoveField(toRemove) {
				currentFieldsWrapper.currentFields =
					currentFieldsWrapper.currentFields.filter(
						(field) => field !== toRemove,
					)
			},
			setValue(key, newValue) {
				emit('input', {
					...props.value,
					[key]: newValue,
				})
			},
			validators: computed(() => props.validators),
			values,
		})

		const validations = computed(() =>
			currentFieldsWrapper.currentFields.map((field) => field.validation),
		)

		const valueIsValid = ({ type }: KottiField.Validation.Result) => {
			switch (props.preventSubmissionOn) {
				case 'warning':
					if (type === 'warning') return false
				// fall through
				case 'error':
					if (type === 'error') return false
				// fall through
				default:
					return true
			}
		}

		const validationSummary = computed(() =>
			getValidationSummary(validations.value),
		)

		const isValid = computed(() => validations.value.every(valueIsValid))

		provide<KottiForm.SubmitContext>(KT_FORM_SUBMIT_CONTEXT, {
			isLoading,
			isValid,
			validationSummary,
		})

		return {
			onSubmit() {
				switch (props.preventSubmissionOn) {
					case 'warning':
						if (validationSummary.value.warnings.length > 0)
							throw new KtFormErrors.ValidationError(
								props,
								'warning',
								validationSummary.value.warnings,
							)
					// fall through
					case 'error':
						if (validationSummary.value.errors.length > 0)
							throw new KtFormErrors.ValidationError(
								props,
								'error',
								validationSummary.value.errors,
							)
					// fall through
					case 'NEVER':
						break
				}

				if (!isValid.value)
					throw new KtFormErrors.UnexpectedValidationState(props)

				const onSubmitData: KottiForm.Events.Submit = {
					validationSummary: validationSummary.value,
					values: values.value,
				}

				/**
				 * Deep-clone to prevent users from accidentally modifying the internal state
				 */
				emit('submit', cloneDeep(onSubmitData))
			},
			validations,
		}
	},
})
</script>
