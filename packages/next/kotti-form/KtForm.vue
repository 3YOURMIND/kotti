<template>
	<form @submit.prevent="onSubmit">
		<slot name="default" />
		<!-- onSubmit only triggers if there is a submit button in the form -->
		<input v-show="false" type="submit" />
	</form>
</template>

<script lang="ts">
import {
	computed,
	defineComponent,
	provide,
	reactive,
} from '@vue/composition-api'
import cloneDeep from 'lodash/cloneDeep'

import { KottiField } from '../kotti-field/types'

import { KT_FORM_CONTEXT } from './constants'
import { KtFormErrors } from './errors'
import { KottiForm } from './types'
import { getValidationSummary } from './utilities'

let id = 0

export default defineComponent({
	name: 'KtForm',
	props: {
		formId: { default: () => `autoGeneratedFormId${++id}`, type: String },
		hideValidation: { default: false, type: Boolean },
		isLoading: { default: false, type: Boolean },
		preventSubmissionOn: {
			default: 'error',
			type: String,
			validator: (
				value: string,
			): value is KottiForm.Props['preventSubmissionOn'] =>
				['error', 'warning', 'NEVER'].includes(value),
		},
		validators: { default: () => ({}), type: Object },
		value: { required: true, type: Object },
	},
	setup(props: KottiForm.Props, { emit }) {
		const currentFieldsWrapper = reactive<{
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			currentFields: KottiField.Hook.Returns<any>[]
		}>({ currentFields: [] })

		const values = computed(() => cloneDeep(props.value))

		provide<KottiForm.Context>(KT_FORM_CONTEXT, {
			formPath: computed(() => [props.formId]),
			hideValidation: computed(() => props.hideValidation),
			isLoading: computed(() => props.isLoading),
			onAddField(toAdd) {
				currentFieldsWrapper.currentFields = [
					...currentFieldsWrapper.currentFields,
					toAdd,
				]
			},
			onRemoveField(toRemove) {
				currentFieldsWrapper.currentFields = currentFieldsWrapper.currentFields.filter(
					(field) => field !== toRemove,
				)
			},
			setValue(key, newValue) {
				emit('input', {
					...props.value,
					[key]: newValue,
				})
			},
			validators: computed(() => props.validators),
			values,
		})

		const validations = computed(() =>
			currentFieldsWrapper.currentFields.map((field) => field.validation),
		)

		const valueIsValid = ({ type }: KottiField.Validation.Result) => {
			switch (props.preventSubmissionOn) {
				case 'warning':
					if (type === 'warning') return false
				// fall through
				case 'error':
					if (type === 'error') return false
				// fall through
				default:
					return true
			}
		}

		const isValid = computed(() => validations.value.every(valueIsValid))

		return {
			onSubmit() {
				const validationSummary = getValidationSummary(validations.value)

				switch (props.preventSubmissionOn) {
					case 'warning':
						if (validationSummary.warnings.length > 0)
							throw new KtFormErrors.ValidationError(
								props,
								'warning',
								validationSummary.warnings,
							)
					// fall through
					case 'error':
						if (validationSummary.errors.length > 0)
							throw new KtFormErrors.ValidationError(
								props,
								'error',
								validationSummary.errors,
							)
					// fall through
					case 'NEVER':
						break
				}

				if (!isValid.value)
					throw new KtFormErrors.UnexpectedValidationState(props)

				const onSubmitData: KottiForm.Events.Submit = {
					validationSummary,
					values: values.value,
				}

				/**
				 * Deep-clone to prevent users from accidentally modifying the internal state
				 */
				emit('submit', cloneDeep(onSubmitData))
			},
			validations,
		}
	},
})
</script>
